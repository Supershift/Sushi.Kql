using System.Data;
using System.Linq.Expressions;
using System.Text;
using Sushi.Kql.AggregationFunctions;
using Sushi.Kql.Mapping;
using Sushi.Kql.Tabular;

namespace Sushi.Kql;

/// <summary>
/// Builds a KQL query with a fluent API.
/// </summary>
/// <typeparam name="T"></typeparam>
public class QueryBuilder<T> : IQueryBuilder
{
    private readonly DataMap<T> _map;
    private readonly StringBuilder _builder;
    private readonly ParameterCollection _parameters;

    /// <summary>
    /// Creates a new instance of <see cref="QueryBuilder{T}"/> using the map's table name.
    /// </summary>        
    public QueryBuilder(DataMap<T> map) : this(map, map.TableName!)
    {
    }    

    /// <summary>
    /// Creates a new instance of <see cref="QueryBuilder{T}"/> for the provided <paramref name="tableName"/>.
    /// </summary>        
    public QueryBuilder(DataMap<T> map, string tableName) : this(map, new StringBuilder(), new ParameterCollection(), tableName)
    {
    }    

    private QueryBuilder(DataMap<T> map, StringBuilder builder, ParameterCollection parameters, string tableName)
    {
        ArgumentNullException.ThrowIfNull(tableName);
        _map = map;
        _builder = builder;        
        _parameters = parameters;
        builder.Append(tableName);
    }

    /// <summary>
    /// Gets the map used in the query builder.
    /// </summary>
    /// <returns></returns>
    public DataMap<T> GetMap()
    {
        return _map;
    }

    /// <summary>
    /// Adds a line of plain text KQL to the query.
    /// </summary>
    /// <param name="kql"></param>
    public void AddKql(string kql)
    {
        _builder.AppendLine();
        _builder.Append("| ").Append(kql);
    }

    /// <summary>
    /// Creates a new WHERE clause in the query. Chain predicates directly, e.g. Query.Where().Equals(x=>x.Column, value).Equals(x => x.OtherColumn, otherValue).
    /// </summary>
    /// <returns></returns>
    public WhereBuilder<T> Where()
    {
        _builder.AppendLine();
        return new WhereBuilder<T>(_map, _builder, _parameters);
    }

    /// <summary>
    /// Selects data from the table.
    /// </summary>
    /// <returns></returns>
    public SelectBuilder<T> Select()
    {
        _builder.AppendLine();
        return new SelectBuilder<T>(_map, _builder, _parameters);
    }

    /// <summary>
    /// Groups and aggregates data.
    /// </summary>
    /// <returns></returns>
    public SummarizeBuilder<T> Summarize()
    {
        _builder.AppendLine();
        return new SummarizeBuilder<T>(_map, _builder, _parameters);
    }

    /// <summary>
    /// Limits the results to a specified number of rows.
    /// </summary>        
    /// <returns></returns>
    public void Top(int numberOfRows, string expression, SortDirection? sortDirection = null)
    {
        _builder.AppendLine();
        _builder.Append($"| top({numberOfRows}) by {expression}");
        if (sortDirection != null)
            _builder.Append(' ').Append(sortDirection.Value.ToString().ToLower());
    }

    /// <summary>
    /// Binds a name to all previous input in the query, allowing it to be referenced later in the query by the name.
    /// </summary>
    /// <param name="name"></param>
    /// <param name="materialize">If true, the inpuit is wrapped by a materialize() function call. Otherwise, the value is recalculated on every reference.</param>
    public void As(string name, bool materialize = false)
    {
        _builder.AppendLine();
        _builder.Append("| as");
        if (materialize)
            _builder.Append(" hint.materialized=true");
        _builder.Append(' ').Append(name);
    }

    /// <summary>
    /// Joins current query with query generated by <paramref name="queryBuilder"/>.
    /// </summary>    
    public void Union(Action<QueryBuilder<T>> queryBuilder, string? withsourceName = null, string? queryBuilderTableName = null)
    {
        // use map<T>'s tablename or the one provided as override
        string tableName = queryBuilderTableName ?? _map.TableName!;

        // create new querybuilder for the union, passing the existing parametercollection to keep those parameters unique
        var qb = new QueryBuilder<T>(_map, new StringBuilder(), _parameters, tableName);

        // call unionBuilder action
        queryBuilder(qb);

        // get kql for query to join
        string unionKql = qb.ToKqlString(false);

        // build union in query
        _builder.AppendLine();
        _builder.Append("| union ");
        if(!string.IsNullOrWhiteSpace(withsourceName))
            _builder.Append($"withsource={withsourceName} ");
        _builder.Append($"({unionKql})");
    }

    /// <summary>
    /// Expands multi-value dynamic arrays or property bags into multiple records.
    /// </summary>
    public MvExpandBuilder<T> MvExpand()
    {
        return new MvExpandBuilder<T>(_builder, _map);
    }

    /// <inheritdoc />
    public string ToKqlString(bool declareParameters = true)
    {
        // add parameters
        if (declareParameters && _parameters.Count > 0)
        {
            var parameters = _parameters.GetParameters();            
            var stringified = string.Join(", ", parameters.Select(x => $"{x.Name}:{x.Type}"));
            _builder.Insert(0, $"declare query_parameters({stringified});{Environment.NewLine}");            
        }
        return _builder.ToString();
    }

    /// <summary>
    /// Gets the parameters used in the query.
    /// </summary>
    /// <returns></returns>
    public Dictionary<string, string> GetParameters()
    {
        return _parameters.GetParameters().ToDictionary(x => x.Name, x => x.Value);
    }

    /// <summary>
    /// Limits output to a specified number of rows. Unless the data is sorted, the rows returned are not guaranteed to be the same each time the query is run.
    /// </summary>
    /// <param name="numberOfRows"></param>
    public void Limit(int numberOfRows)
    {
        _builder.AppendLine();
        _builder.Append($"| limit {numberOfRows}");
    }

    /// <summary>
    /// Takes N number of rows of rows. Unless the data is sorted, the rows returned are not guaranteed to be the same each time the query is run.
    /// </summary>
    /// <param name="numberOfRows"></param>
    public void Take(int numberOfRows)
    {
        _builder.AppendLine();
        _builder.Append($"| take {numberOfRows}");
    }
}
