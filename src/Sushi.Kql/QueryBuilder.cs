using System.Data;
using System.Linq.Expressions;
using System.Text;
using Sushi.Kql.AggregationFunctions;
using Sushi.Kql.Mapping;
using Sushi.Kql.Tabular;

namespace Sushi.Kql;

/// <summary>
/// Builds a KQL query with a fluent API.
/// </summary>
/// <typeparam name="T"></typeparam>
public class QueryBuilder<T> : IQueryBuilder
{
    private readonly DataMap<T> _map;
    private readonly StringBuilder _builder;    

    /// <summary>
    /// Creates a new instance of <see cref="QueryBuilder{T}"/> using the map's table name.
    /// </summary>        
    public QueryBuilder(DataMap<T> map) : this(map, map.TableName!)
    {
    }

    /// <summary>
    /// Creates a new instance of <see cref="QueryBuilder{T}"/> for the provided <paramref name="tableName"/>.
    /// </summary>        
    public QueryBuilder(DataMap<T> map, string tableName) : this(map, new StringBuilder(), new ParameterCollection(), tableName)
    {
    }

    internal QueryBuilder(DataMap<T> map, StringBuilder builder, ParameterCollection parameters, string tableName)
    {
        ArgumentNullException.ThrowIfNull(tableName);
        _map = map;
        _builder = builder;
        Parameters = parameters;
        builder.Append(tableName);
    }

    /// <summary>
    /// Gets the parameters used in the query.
    /// </summary>
    public ParameterCollection Parameters { get; }

    /// <summary>
    /// Gets the map used in the query builder.
    /// </summary>
    /// <returns></returns>
    public DataMap<T> GetMap()
    {
        return _map;
    }

    /// <summary>
    /// Adds a line of plain text KQL to the query.
    /// </summary>
    /// <param name="kql"></param>
    public void AddKql(string kql)
    {
        _builder.AppendLine();
        _builder.Append("| ").Append(kql);
    }

    /// <summary>
    /// Creates a new WHERE clause in the query. Chain predicates directly, e.g. Query.Where().Equals(x=>x.Column, value).Equals(x => x.OtherColumn, otherValue).
    /// </summary>
    /// <returns></returns>
    public WhereBuilder<T> Where()
    {
        _builder.AppendLine();
        return new WhereBuilder<T>(_map, _builder, Parameters);
    }

    /// <summary>
    /// Selects data from the table.
    /// </summary>
    /// <returns></returns>
    public SelectBuilder<T> Select()
    {
        _builder.AppendLine();
        return new SelectBuilder<T>(_map, _builder, Parameters);
    }

    /// <summary>
    /// Groups and aggregates data.
    /// </summary>
    /// <returns></returns>
    public SummarizeBuilder<T> Summarize()
    {
        _builder.AppendLine();
        return new SummarizeBuilder<T>(_map, _builder, Parameters);
    }

    /// <summary>
    /// Limits the results to a specified number of rows.
    /// </summary>        
    /// <returns></returns>
    public void Top(int numberOfRows, string expression, SortDirection? sortDirection = null)
    {
        _builder.AppendLine();
        _builder.Append($"| top({numberOfRows}) by {expression}");
        if (sortDirection != null)
            _builder.Append(' ').Append(sortDirection.Value.ToString().ToLower());
    }

    /// <summary>
    /// Limits the results to a specified number of rows.
    /// </summary>        
    /// <returns></returns>
    public void Top(int numberOfRows, Expression<Func<T, object?>> column, SortDirection? sortDirection = null)
    {
        var dataMapItem = _map.GetItem(column);
        Top(numberOfRows, dataMapItem.Column, sortDirection);
    }

    /// <summary>
    /// Binds a name to all previous input in the query, allowing it to be referenced later in the query by the name.
    /// </summary>
    /// <param name="name"></param>
    /// <param name="materialize">If true, the inpuit is wrapped by a materialize() function call. Otherwise, the value is recalculated on every reference.</param>
    public void As(string name, bool materialize = false)
    {
        _builder.AppendLine();
        _builder.Append("| as");
        if (materialize)
            _builder.Append(" hint.materialized=true");
        _builder.Append(' ').Append(name);
    }

    /// <summary>
    /// Joins current query with query generated by <paramref name="unionBuilder"/>.
    /// </summary>    
    public void Union(Action<UnionBuilder<T>> unionBuilder)
    {
        var ub = new UnionBuilder<T>(_map, _builder, Parameters);
        
        _builder.AppendLine();
        _builder.Append("| union ");
        
        unionBuilder(ub);
    }

    /// <summary>
    /// Expands multi-value dynamic arrays or property bags into multiple records.
    /// </summary>
    public MvExpandBuilder<T> MvExpand()
    {
        return new MvExpandBuilder<T>(_builder, _map);
    }

    /// <summary>
    /// Sorts the rows of the input table into order by one or more columns.
    /// </summary>        
    public SortBuilder<T> Sort()
    {
        _builder.AppendLine();
        return new SortBuilder<T>(_map, _builder);
    }

    /// <inheritdoc />
    public string ToKqlString(bool declareParameters = true)
    {
        // add parameters
        if (declareParameters && Parameters.Count > 0)
        {
            var parameters = Parameters.GetParameters();
            var stringified = string.Join(", ", parameters.Select(x => $"{x.Name}:{x.Type}"));
            _builder.Insert(0, $"declare query_parameters({stringified});{Environment.NewLine}");
        }
        return _builder.ToString();
    }

    /// <summary>
    /// Gets the parameters used in the query.
    /// </summary>
    /// <returns></returns>
    public Dictionary<string, string> GetParameters()
    {
        return Parameters.GetParameters().ToDictionary(x => x.Name, x => x.Value);
    }

    /// <summary>
    /// Limits output to a specified number of rows. Unless the data is sorted, the rows returned are not guaranteed to be the same each time the query is run.
    /// </summary>
    /// <param name="numberOfRows"></param>
    public void Limit(int numberOfRows)
    {
        _builder.AppendLine();
        _builder.Append($"| limit {numberOfRows}");
    }

    /// <summary>
    /// Takes N number of rows of rows. Unless the data is sorted, the rows returned are not guaranteed to be the same each time the query is run.
    /// </summary>
    /// <param name="numberOfRows"></param>
    public void Take(int numberOfRows)
    {
        _builder.AppendLine();
        _builder.Append($"| take {numberOfRows}");
    }

    /// <summary>
    /// Triggers the query side-effect with actually returning the results back to the client.
    /// </summary>
    public void Consume()
    {
        _builder.AppendLine();
        _builder.Append($"| consume");
    }


}
